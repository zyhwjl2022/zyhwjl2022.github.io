[{"title":"Eclipse快捷键","url":"/2020/09/08/Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/","content":"\nAlt+&#x2F;\t自动补全\nCtrl+&#x2F;\t注释\nsyso+自动补全\tsystem.out.println(“”);\nAlt+Shift+R     批量改名(参数、变量、常量)\n\n","categories":["学习","Java","Eclipse技巧"],"tags":["技巧"]},{"title":"Frp服务开机自启","url":"/2021/04/12/Frp%E6%9C%8D%E5%8A%A1%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/","content":"配置文件创建服务文件sudo vim /etc/systemd/system/frps.service\n填入如下信息ExecStart请自行替换\n[Unit]Description=Frp ServerAfter=network.targetWants=network.target[Service]Restart=on-failureRestartSec=5ExecStart=/usr/local/frp/frps_linux_arm -c /usr/local/frp/frps.ini  #目标文件#FRPC--ExecStart=/usr/local/frp/frpc_linux_arm -c /usr/local/frp/frpc.ini [Install]WantedBy=multi-user.target\n\n\n\n使用方法\n#刷新服务列表：systemctl daemon-reload#设置开机自启systemctl enable frps#关闭开机自启systemctl disable frps#启动服务systemctl start frps#停止服务systemctl stop frps#重启服务systemctl restart frps\n\n","categories":["Linux","实用","内网穿透"],"tags":["折腾"]},{"title":"Git","url":"/2021/05/13/Git/","content":"Git\nGit 工作区、暂存区和版本库\n基本概念我们先来理解下 Git 工作区、暂存区和版本库概念：\n\n工作区：就是你在电脑里能看到的目录。\n暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git&#x2F;index）中，所以我们把暂存区有时也叫作索引（index）。\n版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。\n\n下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：\n\n\n图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage&#x2F;index），标记为 “master” 的是 master 分支所代表的目录树。\n图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。\n图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git&#x2F;objects” 目录下，里面包含了创建的各种对象及内容。\n当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。\n当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。\n当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。\n当执行 git rm –cached  命令时，会直接从暂存区删除文件，工作区则不做出改变。\n当执行 git checkout . 或者 git checkout –  命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。\n当执行 git checkout HEAD . 或者 git checkout HEAD  命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。\n\nGit 创建仓库本章节我们将为大家介绍如何创建一个 Git 仓库。\n你可以使用一个已经存在的目录作为Git仓库。\n\ngit initGit 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。\n在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。\n使用方法使用当前目录作为Git仓库，我们只需使它初始化。\ngit init\n\n该命令执行完后会在当前目录生成一个 .git 目录。\n使用我们指定目录作为Git仓库。\ngit init newrepo\n\n初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。\n如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：\n$ git add *.c$ git add README$ git commit -m &#x27;初始化项目版本&#x27;\n\n以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。\n\n注： 在 Linux 系统中，commit 信息使用单引号 **’**，Windows 系统，commit 信息使用双引号 **”**。\n所以在 git bash 中 git commit -m ‘提交说明’ 这样是可以的，在 Windows 命令行中就要使用双引号 **git commit -m “提交说明”**。\n\n\ngit clone我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。\n克隆仓库的命令格式为：\ngit clone &lt;repo&gt;\n\n如果我们需要克隆到指定的目录，可以使用以下命令格式：\ngit clone &lt;repo&gt; &lt;directory&gt;\n\n参数说明：\n\n**repo:**Git 仓库。\n**directory:**本地目录。\n\n比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：\n$ git clone git://github.com/schacon/grit.git\n\n执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。\n如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：\n$ git clone git://github.com/schacon/grit.git mygrit\n\n配置git 的设置使用 git config 命令。\n显示当前的 git 配置信息：\n$ git config --listcredential.helper=osxkeychaincore.repositoryformatversion=0core.filemode=truecore.bare=falsecore.logallrefupdates=truecore.ignorecase=truecore.precomposeunicode=true\n\n编辑 git 配置文件:\n$ git config -e    # 针对当前仓库 \n\n或者：\n$ git config -e --global   # 针对系统上所有仓库\n\n设置提交代码时的用户信息：\n$ git config --global user.name &quot;runoob&quot;$ git config --global user.email test@runoob.com\n\n如果去掉 –global 参数只对当前仓库有效。\nGit 基本操作Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。\n本章将对有关创建与提交你的项目快照的命令作介绍。\nGit 常用的是以下 6 个命令：git clone、git push、git add 、git commit、git checkout、git pull，后面我们会详细介绍。\n\n说明：\n\nworkspace：工作区\nstaging area：暂存区&#x2F;缓存区\nlocal repository：版本库或本地仓库\nremote repository：远程仓库\n\n一个简单的操作步骤：\n$ git init    $ git add .    $ git commit  \n\n\ngit init - 初始化仓库。\ngit add . - 添加文件到暂存区。\ngit commit - 将暂存区内容添加到仓库中。\n\n创建仓库命令下表列出了 git 创建仓库的命令：\n\n\n\n命令\n说明\n\n\n\ngit init\n初始化仓库\n\n\ngit clone\n拷贝一份远程仓库，也就是下载一个项目。\n\n\n\n提交与修改Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。\n下表列出了有关创建与提交你的项目的快照的命令：\n\n\n\n命令\n说明\n\n\n\ngit add\n添加文件到仓库\n\n\ngit status\n查看仓库当前的状态，显示有变更的文件。\n\n\ngit diff\n比较文件的不同，即暂存区和工作区的差异。\n\n\ngit commit\n提交暂存区到本地仓库。\n\n\ngit reset\n回退版本。\n\n\ngit rm\n删除工作区文件。\n\n\ngit mv\n移动或重命名工作区文件。\n\n\n提交日志\n\n\n命令\n说明\n\n\n\ngit log\n查看历史提交记录\n\n\ngit blame &lt;file&gt;\n以列表形式查看指定文件的历史修改记录\n\n\n远程操作\n\n\n命令\n说明\n\n\n\ngit remote\n远程仓库操作\n\n\ngit fetch\n从远程获取代码库\n\n\ngit pull\n下载远程代码并合并\n\n\ngit push\n上传远程代码并合并\n\n\nGit 分支管理几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。\n有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。\n创建分支命令：\ngit branch (branchname)\n\n切换分支命令:\ngit checkout (branchname)\n\n当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。\n合并分支命令:\ngit merge \n\n你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。\n开始前我们先创建一个测试目录：\n$ mkdir gitdemo$ cd gitdemo/$ git initInitialized empty Git repository...$ touch README$ git add README$ git commit -m &#x27;第一次版本提交&#x27;[master (root-commit) 3b58100] 第一次版本提交 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README\n\n\nGit 分支管理列出分支列出分支基本命令：\ngit branch\n\n没有参数时，git branch 会列出你在本地的分支。\n$ git branch* master\n\n此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。\n当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。\n如果我们要手动创建一个分支。执行 git branch (branchname) 即可。\n$ git branch testing$ git branch* master  testing\n\n现在我们可以看到，有了一个新分支 testing。\n当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支时候的样子。\n接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。\n$ lsREADME$ echo &#x27;runoob.com&#x27; &gt; test.txt$ git add .$ git commit -m &#x27;add test.txt&#x27;[master 3e92c19] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt$ lsREADME        test.txt$ git checkout testingSwitched to branch &#x27;testing&#x27;$ lsREADME\n\n当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们有重新出现了。\n$ git checkout masterSwitched to branch &#x27;master&#x27;$ lsREADME        test.txt\n\n我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。\n$ git checkout -b newtestSwitched to a new branch &#x27;newtest&#x27;$ git rm test.txt rm &#x27;test.txt&#x27;$ lsREADME$ touch runoob.php$ git add .$ git commit -am &#x27;removed test.txt、add runoob.php&#x27;[newtest c1501a2] removed test.txt、add runoob.php 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME        runoob.php$ git checkout masterSwitched to branch &#x27;master&#x27;$ lsREADME        test.txt\n\n如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。\n使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。\n删除分支删除分支命令：\ngit branch -d (branchname)\n\n例如我们要删除 testing 分支：\n$ git branch* master  testing$ git branch -d testingDeleted branch testing (was 85fc7e7).$ git branch* master\n\n分支合并一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：\ngit merge$ git branch* master  newtest$ lsREADME        test.txt$ git merge newtestUpdating 3e92c19..c1501a2Fast-forward runoob.php | 0 test.txt   | 1 - 2 files changed, 1 deletion(-) create mode 100644 runoob.php delete mode 100644 test.txt$ lsREADME        runoob.php\n\n以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。\n合并完后就可以删除分支:\n$ git branch -d newtestDeleted branch newtest (was c1501a2).\n\n删除后， 就只剩下 master 分支了：\n$ git branch* master\n\n合并冲突合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。\n$ git branch* master$ cat runoob.php\n\n首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:\n&lt;?phpecho &#x27;runoob&#x27;;?&gt;\n\n创建 change_site 分支：\n$ git checkout -b change_siteSwitched to a new branch &#x27;change_site&#x27;$ vim runoob.php$ head -3 runoob.php&lt;?phpecho &#x27;runoob&#x27;;?&gt;$ git commit -am &#x27;changed the runoob.php&#x27;[change_site 7774248] changed the runoob.php 1 file changed, 3 insertions(+) \n\n将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。\n$ git checkout masterSwitched to branch &#x27;master&#x27;$ cat runoob.php$ vim runoob.php    # 修改内容如下$ cat runoob.php&lt;?phpecho 1;?&gt;$ git diffdiff --git a/runoob.php b/runoob.phpindex e69de29..ac60739 100644--- a/runoob.php+++ b/runoob.php@@ -0,0 +1,3 @@+&lt;?php+echo 1;+?&gt;$ git commit -am &#x27;修改代码&#x27;[master c68142b] 修改代码 1 file changed, 3 insertions(+)\n\n现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。\n$ git merge change_siteAuto-merging runoob.phpCONFLICT (content): Merge conflict in runoob.phpAutomatic merge failed; fix conflicts and then commit the result.$ cat runoob.php     # 代开文件，看到冲突内容&lt;?php&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADecho 1;=======echo &#x27;runoob&#x27;;&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site?&gt;\n\n我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。\n$ vim runoob.php $ cat runoob.php&lt;?phpecho 1;echo &#x27;runoob&#x27;;?&gt;$ git diffdiff --cc runoob.phpindex ac60739,b63d7d7..0000000--- a/runoob.php+++ b/runoob.php@@@ -1,3 -1,3 +1,4 @@@  &lt;?php +echo 1;+ echo &#x27;runoob&#x27;;  ?&gt;\n\n在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决\n$ git status -sUU runoob.php$ git add runoob.php$ git status -sM  runoob.php$ git commit[master 88afe0e] Merge branch &#x27;change_site&#x27;\n\n现在我们成功解决了合并中的冲突，并提交了结果。\nGit 查看提交历史Git 提交历史一般常用两个命令：\n\ngit log - 查看历史提交记录。\n\ngit blame  - 以列表形式查看指定文件的历史修改记录。\n\ngit log\n在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。\n\n针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：\n\n$ git log\ncommit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)\nMerge: c68142b 7774248\nAuthor: runoob &lt;test@runoob.com&gt;\nDate:   Fri May 3 15:55:58 2019 +0800\n\n    Merge branch &#39;change_site&#39;\n\ncommit c68142b562c260c3071754623b08e2657b4c6d5b\nAuthor: runoob &lt;test@runoob.com&gt;\nDate:   Fri May 3 15:52:12 2019 +0800\n\n    修改代码\n\ncommit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)\nAuthor: runoob &lt;test@runoob.com&gt;\nDate:   Fri May 3 15:49:26 2019 +0800\n\n    changed the runoob.php\n\ncommit c1501a244676ff55e7cccac1ecac0e18cbf6cb00\nAuthor: runoob &lt;test@runoob.com&gt;\nDate:   Fri May 3 15:35:32 2019 +0800\n- 我们可以用 --oneline 选项来查看历史记录的简洁的版本。- ```  $ git log --oneline  $ git log --oneline  d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;  c68142b 修改代码  7774248 (change_site) changed the runoob.php  c1501a2 removed test.txt、add runoob.php  3e92c19 add test.txt  3b58100 第一次版本提交\n\n\n这告诉我们的是，此项目的开发历史。\n\n我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：\n\n*   d5e9fc2 (HEAD -&gt; master) Merge branch &#39;change_site&#39;\n|\\  \n| * 7774248 (change_site) changed the runoob.php\n* | c68142b 修改代码\n|/  \n* c1501a2 removed test.txt、add runoob.php\n* 3e92c19 add test.txt\n* 3b58100 第一次版本提交\n- 现在我们可以更清楚明了地看到何时工作分叉、又何时归并。- 你也可以用 **--reverse** 参数来逆向显示所有日志。- ```  $ git log --reverse --oneline  3b58100 第一次版本提交  3e92c19 add test.txt  c1501a2 removed test.txt、add runoob.php  7774248 (change_site) changed the runoob.php  c68142b 修改代码  d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;\n\n\n如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：\n\n$ git log --author=Linus --oneline -5\n81b50f3 Move &#39;builtin-*&#39; into a &#39;builtin/&#39; subdirectory\n3bb7256 make &quot;index-pack&quot; a built-in\n377d027 make &quot;git pack-redundant&quot; a built-in\nb532581 make &quot;git unpack-file&quot; a built-in\n112dd51 make &quot;mktag&quot; a built-in\n- 如果你要指定日期，可以执行几个选项：--since 和 --before，但是你也可以用 --until 和 --after。- 例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 --no-merges 选项以隐藏合并提交）：- ```  $ git log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges  5469e2d Git 1.7.1-rc2  d43427d Documentation/remote-helpers: Fix typos and improve language  272a36b Fixup: Second argument may be any arbitrary string  b6c8d2d Documentation/remote-helpers: Add invocation section  5ce4f4e Documentation/urls: Rewrite to accomodate transport::address  00b84e9 Documentation/remote-helpers: Rewrite description  03aa87e Documentation: Describe other situations where -z affects git diff  77bc694 rebase-interactive: silence warning when no commits rewritten  636db2c t3301: add tests to use --format=&quot;%N&quot;\n\n\n更多 git log 命令可查看：http://git-scm.com/docs/git-log\n\ngit blame\n如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：\n\n&#96;&#96;&#96;git blame \n- git blame 命令是以列表形式显示修改记录，如下实例：- ```  $ git blame README   ^d2097aa (tianqixin 2020-08-25 14:59:25 +0800 1) # Runoob Git 测试  db9315b0 (runoob    2020-08-25 16:00:23 +0800 2) # 菜鸟教程 \n\nGit 标签如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。\n比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。\n-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。\n$ git tag -a v1.0 \n\n当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。\n现在，注意当我们执行 git log –decorate 时，我们可以看到我们的标签了：\n*   d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;|\\  | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/  * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 第一次版本提交\n\n如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。\n例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：\n$ git tag -a v0.9 85fc7e7$ git log --oneline --decorate --graph*   d5e9fc2 (HEAD -&gt; master) Merge branch &#x27;change_site&#x27;|\\  | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/  * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 (tag: v0.9) 第一次版本提交\n\n如果我们要查看所有标签可以使用以下命令：\n$ git tagv0.9v1.0\n\n指定标签信息命令：\ngit tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;\n\nPGP签名标签命令：\ngit tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;\n\nGit 远程仓库(Github)Git 并不像 SVN 那样有个中心服务器。\n目前我们使用到的 Git 命令都是在本地执行，如果你想通过 Git 分享你的代码或者与其他开发人员合作。 你就需要将数据放到一台其他开发人员能够连接的服务器上。\n本例使用了 Github 作为远程仓库，你可以先阅读我们的 Github 简明教程。\n\n\n添加远程库要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：\ngit remote add [shortname] [url]\n\n本例以 Github 为例作为远程仓库，如果你没有 Github 可以在官网 https://github.com/注册。\n由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：\n使用以下命令生成 SSH Key：\n$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;\n\n后面的 &#121;&#111;&#117;&#x72;&#95;&#x65;&#x6d;&#x61;&#x69;&#108;&#64;&#x79;&#x6f;&#117;&#114;&#101;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#x6d; 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。\n成功的话会在 ~&#x2F; 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。\n$ ssh-keygen -t rsa -C &quot;429240967@qq.com&quot;Generating public/private rsa key pair.Enter file in which to save the key (/Users/tianqixin/.ssh/id_rsa): Enter passphrase (empty for no passphrase):    # 直接回车Enter same passphrase again:                   # 直接回车Your identification has been saved in /Users/tianqixin/.ssh/id_rsa.Your public key has been saved in /Users/tianqixin/.ssh/id_rsa.pub.The key fingerprint is:SHA256:MDKVidPTDXIQoJwoqUmI4LBAsg5XByBlrOEzkxrwARI 429240967@qq.comThe key&#x27;s randomart image is:+---[RSA 3072]----+|E*+.+=**oo       ||%Oo+oo=o. .      ||%**.o.o.         ||OO.  o o         ||+o+     S        ||.                ||                 ||                 ||                 |+----[SHA256]-----+\n\n回到 github 上，进入 Account &#x3D;&gt; Settings（账户配置）。\n\n左边选择 SSH and GPG keys，然后点击 New SSH key 按钮,title 设置标题，可以随便填，粘贴在你电脑上生成的 key。\n\n\n添加成功后界面如下所示\n\n为了验证是否成功，输入以下命令：\n$ ssh -T git@github.comThe authenticity of host &#x27;github.com (52.74.223.119)&#x27; can&#x27;t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no/[fingerprint])? yes                   # 输入 yesWarning: Permanently added &#x27;github.com,52.74.223.119&#x27; (RSA) to the list of known hosts.Hi tianqixin! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. # 成功信息\n\n以下命令说明我们已成功连上 Github。\n之后登录后点击” New repository “ 如下图所示：\n\n之后在在Repository name 填入 runoob-git-test(远程仓库名) ，其他保持默认设置，点击”Create repository”按钮，就成功地创建了一个新的Git仓库：\n\n创建成功后，显示如下信息：\n\n以上信息告诉我们可以从这个仓库克隆出新的仓库，也可以把本地仓库的内容推送到GitHub仓库。\n现在，我们根据 GitHub 的提示，在本地的仓库下运行命令：\n$ mkdir runoob-git-test                     # 创建测试目录$ cd runoob-git-test/                       # 进入测试目录$ echo &quot;# 菜鸟教程 Git 测试&quot; &gt;&gt; README.md     # 创建 README.md 文件并写入内容$ ls                                        # 查看目录下的文件README$ git init                                  # 初始化$ git add README.md                         # 添加文件$ git commit -m &quot;添加 README.md 文件&quot;        # 提交并备注信息[master (root-commit) 0205aab] 添加 README.md 文件 1 file changed, 1 insertion(+) create mode 100644 README.md# 提交到 Github$ git remote add origin git@github.com:tianqixin/runoob-git-test.git$ git push -u origin master\n\n以下命令请根据你在Github成功创建新仓库的地方复制，而不是根据我提供的命令，因为我们的Github用户名不一样，仓库名也不一样。\n接下来我们返回 Github 创建的仓库，就可以看到文件已上传到 Github上：\n\n\n查看当前的远程库要查看当前配置有哪些远程仓库，可以用命令：\ngit remote\n\n实例$ git remoteorigin$ git remote -vorigin    git@github.com:tianqixin/runoob-git-test.git (fetch)origin    git@github.com:tianqixin/runoob-git-test.git (push)\n\n执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。\n\n提取远程仓库Git 有两个命令用来提取远程仓库的更新。\n1、从远程仓库下载新分支与数据：\ngit fetch\n\n该命令执行完后需要执行 git merge 远程分支到你所在的分支。\n2、从远端仓库提取数据并尝试合并到当前分支：\ngit merge\n\n该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。\n假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]&#x2F;[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。\n接下来我们在 Github 上点击” README.md” 并在线修改它:\n\n然后我们在本地更新修改。\n$ git fetch originremote: Counting objects: 3, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:tianqixin/runoob-git-test   0205aab..febd8ed  master     -&gt; origin/master\n\n以上信息”0205aab..febd8ed master -&gt; origin&#x2F;master” 说明 master 分支已被更新，我们可以使用以下命令将更新同步到本地：\n$ git merge origin/masterUpdating 0205aab..febd8edFast-forward README.md | 1 + 1 file changed, 1 insertion(+)\n\n查看 README.md 文件内容：\n$ cat README.md # 菜鸟教程 Git 测试## 第一次修改内容\n\n\n推送到远程仓库推送你的新分支与数据到某个远端仓库命令:\ngit push [alias] [branch]\n\n以上命令将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支，实例如下。\n$ touch runoob-test.txt      # 添加文件$ git add runoob-test.txt $ git commit -m &quot;添加到远程&quot;master 69e702d] 添加到远程 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 runoob-test.txt$ git push origin master    # 推送到 Github\n\n重新回到我们的 Github 仓库，可以看到文件已经提交上来了：\n\n\n删除远程仓库删除远程仓库你可以使用命令：\ngit remote rm [别名]\n\n实例$ git remote -vorigin    git@github.com:tianqixin/runoob-git-test.git (fetch)origin    git@github.com:tianqixin/runoob-git-test.git (push)# 添加仓库 origin2$ git remote add origin2 git@github.com:tianqixin/runoob-git-test.git$ git remote -vorigin    git@github.com:tianqixin/runoob-git-test.git (fetch)origin    git@github.com:tianqixin/runoob-git-test.git (push)origin2    git@github.com:tianqixin/runoob-git-test.git (fetch)origin2    git@github.com:tianqixin/runoob-git-test.git (push)# 删除仓库 origin2$ git remote rm origin2$ git remote -vorigin    git@github.com:tianqixin/runoob-git-test.git (fetch)origin    git@github.com:tianqixin/runoob-git-test.git (push)\n\nGit Gitee大家都知道国内访问 Github 速度比较慢，很影响我们的使用。\n如果你希望体验到 Git 飞一般的速度，可以使用国内的 Git 托管服务——Gitee（gitee.com）。\nGitee 提供免费的 Git 仓库，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee 还提供了项目管理、代码托管、文档管理的服务，5 人以下小团队免费。\n接下来我们学习一下如何使用 Gitee。\n由于我们的本地 Git 仓库和 Gitee 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息。\n1、我们先在 Gitee 上注册账号并登录后，然后上传自己的 SSH 公钥。\n我们在 Git Github 章节已经生成了自己的 SSH 公钥，所以我们只需要将用户主目录下的 ~&#x2F;.ssh&#x2F;id_rsa.pub 文件的内容粘贴 Gitee 上。\n选择右上角用户头像 -&gt; 设置，然后选择 “SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的 .ssh&#x2F;id_rsa.pub 文件的内容粘贴进去：\n\n\n成功添加后如下图所示：\n\n接下来我们创建一个项目。\n点击右上角的 + 号，新建仓库：\n\n然后添加仓库信息：\n\n创建成功后看到如下信息：\n\n接下来我们看下连接信息：\n\n项目名称最好与本地库保持一致。\n然后，我们在本地库上使用命令 git remote add 把它和 Gitee 的远程库关联：\ngit remote add origin git@gitee.com:imnoob/runoob-test.git\n\n之后，就可以正常地用 git push 和 git pull 推送了！\n如果在使用命令 git remote add 时报错：\ngit remote add origin git@gitee.com:imnoob/runoob-test.gitfatal: remote origin already exists.\n\n这说明本地库已经关联了一个名叫 origin 的远程库，此时，可以先用 git remote -v 查看远程库信息：\ngit remote -vorigin    git@github.com:tianqixin/runoob.git (fetch)origin    git@github.com:tianqixin/runoob.git (push)\n\n可以看到，本地库已经关联了 origin 的远程库，并且，该远程库指向 GitHub。\n我们可以删除已有的 GitHub 远程库：\ngit remote rm origin\n\n再关联 Gitee 的远程库（注意路径中需要填写正确的用户名）：\ngit remote add origin git@gitee.com:imnoob/runoob-test.git\n\n此时，我们再查看远程库信息：\ngit remote -vorigin    git@gitee.com:imnoob/runoob-test.git (fetch)origin    git@gitee.com:imnoob/runoob-test.git (push)\n\n现在可以看到，origin 已经被关联到 Gitee 的远程库了。\n通过 git push 命令就可以把本地库推送到 Gitee 上。\n有的小伙伴又要问了，一个本地库能不能既关联 GitHub，又关联 Gitee 呢？\n答案是肯定的，因为 git 本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。\n使用多个远程库时，我们要注意，git 给远程库起的默认名称是 origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。\n仍然以 runoob-test 本地库为例，我们先删除已关联的名为 origin 的远程库：\ngit remote rm origin\n\n然后，先关联 GitHub 的远程库：\ngit remote add github git@github.com:tianqixin/runoob-git-test.git\n\n注意，远程库的名称叫 github，不叫 origin 了。\n接着，再关联 Gitee 的远程库：\ngit remote add gitee git@gitee.com:imnoob/runoob-test.git\n\n同样注意，远程库的名称叫 gitee，不叫 origin。\n现在，我们用 git remote -v 查看远程库信息，可以看到两个远程库：\ngit remote -vgitee    git@gitee.com:imnoob/runoob-test.git (fetch)gitee    git@gitee.com:imnoob/runoob-test.git (push)github    git@github.com:tianqixin/runoob.git (fetch)github    git@github.com:tianqixin/runoob.git (push)\n\n如果要推送到 GitHub，使用命令：\ngit push github master\n\n如果要推送到 Gitee，使用命令：\ngit push gitee master\n\n这样一来，我们的本地库就可以同时与多个远程库互相同步：\n\nGit 服务器搭建上一章节中我们远程仓库使用了 Github，Github 公开的项目是免费的，2019 年开始 Github 私有存储库也可以无限制使用。\n这当然我们也可以自己搭建一台 Git 服务器作为私有仓库使用。\n接下来我们将以 Centos 为例搭建 Git 服务器。\n1、安装Git$ yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel$ yum install git\n\n接下来我们 创建一个git用户组和用户，用来运行git服务：\n$ groupadd git$ useradd git -g git\n\n2、创建证书登录收集所有需要登录的用户的公钥，公钥位于id_rsa.pub文件中，把我们的公钥导入到&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys文件里，一行一个。\n如果没有该文件创建它：\n$ cd /home/git/$ mkdir .ssh$ chmod 755 .ssh$ touch .ssh/authorized_keys$ chmod 644 .ssh/authorized_keys\n\n\n\n3、初始化Git仓库首先我们选定一个目录作为Git仓库，假定是&#x2F;home&#x2F;gitrepo&#x2F;runoob.git，在&#x2F;home&#x2F;gitrepo目录下输入命令：\n$ cd /home$ mkdir gitrepo$ chown git:git gitrepo/$ cd gitrepo$ git init --bare runoob.gitInitialized empty Git repository in /home/gitrepo/runoob.git/\n\n以上命令Git创建一个空仓库，服务器上的Git仓库通常都以.git结尾。然后，把仓库所属用户改为git：\n$ chown -R git:git runoob.git\n\n4、克隆仓库$ git clone git@192.168.45.4:/home/gitrepo/runoob.gitCloning into &#x27;runoob&#x27;...warning: You appear to have cloned an empty repository.Checking connectivity... done.\n\n192.168.45.4 为 Git 所在服务器 ip ，你需要将其修改为你自己的 Git 服务 ip。\n这样我们的 Git 服务器安装就完成。\n","categories":["折腾"]},{"title":"Github Page重置自定义域名","url":"/2022/11/12/Github%20Page%E9%87%8D%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/","content":"不知出于什么原因，在将HEXO博客推送至Github后，Github Page会将原本设置的自定义域名重置\n以下为CSDN大佬解决方案\n在source文件夹建立CNAME文件并填入你的自定义域名即可\n","categories":["HEXO"],"tags":["折腾"]},{"title":"Github项目同步Gitee","url":"/2022/11/26/Github%E9%A1%B9%E7%9B%AE%E5%90%8C%E6%AD%A5Gitee/","content":"因某些众所周知的原因，国内时常访问Github不顺畅。以及某些开源协议等相关政策问题，可能某天号和库同时都没了。所以同步到Gitee还是有一定必要的。\n\n教程参考使用Github Actions自动同步到Gitee仓库_让梦想疯狂的博客-CSDN博客\n\n操作生成公钥私钥执行命令：ssh-keygen -t rsa -C &quot;youremail@example.com&quot;，连续三次回车，id_rsa 为私钥，id_rsa.pub为公钥如果提示：already exists（已经存在），则可以到电脑位置：C:\\Users\\电脑账号名\\ .ssh 直接使用不使用默认SSH参考：生成&#x2F;添加SSH公钥\n在Github项目配置SSH密钥在Github项目Settings-&gt;Secrets-&gt;Actions，名称为：GITEE_RSA_PRIVATE_KEY，值为：上面生成SSH的私钥\nGitHub配置SSH公钥在GithubSettings-&gt;SSH and GPG keys-&gt;New SSH key，名称为：GITEE_RSA_PUBLIC_KEY，值为：上面生成SSH的公钥\nGitee配置SSH公钥在Gitee设置-&gt;安全设置-&gt;SSH公钥，标题为：GITEE_RSA_PUBLIC_KEY，值为：上面生成SSH的公钥\nGitHub创建Github workflow在Github项目Actions创建一个新的workflow\nname: Sync To Giteeon: [ push, delete, create ]jobs:  build:    runs-on: ubuntu-latest    steps:      - name: Sync to Gitee        uses: wearerequired/git-mirror-action@master        env:          # 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY          SSH_PRIVATE_KEY: $&#123;&#123; secrets.GITEE_RSA_PRIVATE_KEY &#125;&#125;        with:          # 注意替换为你的 GitHub 源仓库地址          source-repo: git@github.com:github-username/github-repositoryname.git          # 注意替换为你的 Gitee 目标仓库地址          destination-repo: git@gitee.com:gitee-username/gitee-repositoryname.git\n\n","categories":["折腾"],"tags":["技术"]},{"title":"Http踩坑","url":"/2021/12/16/Http%E8%B8%A9%E5%9D%91/","content":"关键字Web服务器、Https、宝塔、Host、Header\n起因构建两个站点，分别映射至两个节点，两个节点又分别映射至同一源站。以达到访问两个站点实则是通过两个节点代理进行访问，隐藏真实IP。\n起先搭建完一号站点后，通过修改访问程序，伪造节点请求的数据进行发送。\n无异常。\n然而搭建二号站点后，通过修改后的访问程序进行访问，无论如何都会造成向一号站点请求的异常情况。可两者的域名并不相同，这令我认为是请求程序除了错误。因为通过浏览器直接访问二号网站，是没有异常的。但排查许久没有找出异常点。\n处理通过抓取浏览器的请求数据，找出Header中的Host请求不相同。\n访问程序请求的数据中包含修改的Header，是由节点抓包得到，此Host为源站Host。因此，访问程序将此Host发送至服务器后，Web服务器无法识别程序欲访问哪一站点，故将此请求提交至默认站点（已配置Https&#x2F;第一个搭建的站点），从而造成了此次异常。\n坑点实际也不是坑，究其原因是学艺不精。误以为Web服务由域名而非Host识别欲访问的站点名。唯一的坑点可能是浏览器自动匹配的Host，干扰了Debug方向。\n","categories":["踩坑","宝塔","web服务"],"tags":["踩坑"]},{"title":"IDEA的模板注释","url":"/2021/12/23/IDEA%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%B3%A8%E9%87%8A/","content":"类注释\n可参照说明自行修改\n\n/** * Created with IntelliJ IDEA. * @Author: 你的名字 * @Date: $&#123;YEAR&#125;/$&#123;MONTH&#125;/$&#123;DAY&#125;/$&#123;TIME&#125; * @Description:  */\n\nFile---&gt;Settings----&gt;Editor----&gt;File and Code Templates ---&gt;Includes---&gt;File Header\napplay\n \n\n效果\n\n方法注释\n自己改，前面没’&#x2F;**’，不要自作聪明\n\n*** @Description: $description$* @Param: $params$* @return: $returns$* @Author: 你的名字* @Date: $date$*/\n\n\n\n\n\n为你的模板设置默认值：点击那个Edit variables\n保存后，先按一个&#x2F; * ，紧跟着按Tab键 ，注释就出来了。当然，这个 你可以随便写，最后注释快捷键就是 （&#x2F;  你自定义按键 + Tab）*\n\n效果\n\n\n有小伙伴说注释按下后没出来。没出来的话是不是你操作到方法注释保存时这里有个警示呢？\n\n","categories":["折腾","实用","IDEA"],"tags":["实用"]},{"title":"Java学习-IDEA无限试用 适用于JetBrains全家桶","url":"/2021/09/15/Java%E5%AD%A6%E4%B9%A0-IDEA%E6%97%A0%E9%99%90%E8%AF%95%E7%94%A8%20%E9%80%82%E7%94%A8%E4%BA%8EJetBrains%E5%85%A8%E5%AE%B6%E6%A1%B6/","content":"Eval Reset插件\n项目地址：https://github.com/zhilepeng/ide-eval-resetter\n\n\n打开ide，在Settings&#x2F;Preferences… -&gt; Plugins 内手动添加第三方插件仓库地址：https://plugins.zhile.io 。\n搜索：IDE Eval Reset插件进行安装。如果搜索不到请注意是否做好了上一步？网络是否通畅？插件会提示安装成功。\nhelp—-&gt;eval Reset点击重启ide，即可在再次获取30天试用期。\n\n","categories":["学习","Java","工具","IDEA"],"tags":["学习"]},{"title":"Java学习-疑惑之Spring与Spring Boot","url":"/2021/11/22/Java%E5%AD%A6%E4%B9%A0-%E7%96%91%E6%83%91%E4%B9%8BSpring%E4%B8%8ESpring%20Boot/","content":"概述  对于Spring和SpringBoot到底有什么区别，我听到了很多答案，刚开始迈入学习SpringBoot的我当时也是一头雾水，随着经验的积累、我慢慢理解了这两个框架到底有什么区别，相信对于用了SpringBoot很久的同学来说，还不是很理解SpringBoot到底和Spring有什么区别，看完文章中的比较，或许你有了不同的答案和看法！\n什么是Spring  作为Java开发人员，大家都Spring都不陌生，简而言之，Spring框架为开发Java应用程序提供了全面的基础架构支持。它包含一些很好的功能，如依赖注入和开箱即用的模块，如：Spring JDBC 、Spring MVC 、Spring Security、 Spring AOP 、Spring ORM 、Spring Test，这些模块缩短应用程序的开发时间，提高了应用开发的效率例如，在Java Web开发的早期阶段，我们需要编写大量的代码来将记录插入到数据库中。但是通过使用Spring JDBC模块的JDBCTemplate，我们可以将操作简化为几行代码。\n什么是Spring Boot  Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。\nSpring Boot中的一些特征：\n\n创建独立的Spring应用。\n嵌入式Tomcat、Jetty、 Undertow容器（无需部署war文件）。\n提供的starters 简化构建配置\n尽可能自动配置spring应用。\n提供生产指标,例如指标、健壮检查和外部化配置\n完全没有代码生成和XML配置要求\n\n从配置分析Maven依赖首先，让我们看一下使用Spring创建Web应用程序所需的最小依赖项\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;version&gt;5.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;    &lt;version&gt;5.1.0.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n与Spring不同，Spring Boot只需要一个依赖项来启动和运行Web应用程序：\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n\n在进行构建期间，所有其他依赖项将自动添加到项目中。\n  另一个很好的例子就是测试库。我们通常使用Spring Test，JUnit，Hamcrest和Mockito库。在Spring项目中，我们应该将所有这些库添加为依赖项。但是在Spring Boot中，我们只需要添加spring-boot-starter-test依赖项来自动包含这些库。\nSpring Boot为不同的Spring模块提供了许多依赖项。一些最常用的是：\nspring-boot-starter-data-jpa` `spring-boot-starter-security` `spring-boot-starter-test` `spring-boot-starter-web` `spring-boot-starter-thymeleaf\n\n有关starter的完整列表，请查看Spring文档。\nMVC配置让我们来看一下Spring和Spring Boot创建JSP Web应用程序所需的配置。\nSpring需要定义调度程序servlet，映射和其他支持配置。我们可以使用 web.xml 文件或Initializer类来完成此操作：\npublic class MyWebAppInitializer implements WebApplicationInitializer &#123;      @Override    public void onStartup(ServletContext container) &#123;        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();        context.setConfigLocation(&quot;com.pingfangushi&quot;);          container.addListener(new ContextLoaderListener(context));          ServletRegistration.Dynamic dispatcher = container          .addServlet(&quot;dispatcher&quot;, new DispatcherServlet(context));        dispatcher.setLoadOnStartup(1);        dispatcher.addMapping(&quot;/&quot;);    &#125;&#125;\n\n还需要将@EnableWebMvc注释添加到@Configuration类，并定义一个视图解析器来解析从控制器返回的视图：\n@EnableWebMvc@Configurationpublic class ClientWebConfig implements WebMvcConfigurer &#123;    @Bean   public ViewResolver viewResolver() &#123;      InternalResourceViewResolver bean        = new InternalResourceViewResolver();      bean.setViewClass(JstlView.class);      bean.setPrefix(&quot;/WEB-INF/view/&quot;);      bean.setSuffix(&quot;.jsp&quot;);      return bean;   &#125;&#125;\n\n再来看SpringBoot一旦我们添加了Web启动程序，Spring Boot只需要在application配置文件中配置几个属性来完成如上操作：\nspring.mvc.view.prefix=/WEB-INF/jsp/spring.mvc.view.suffix=.jsp\n\n上面的所有Spring配置都是通过一个名为auto-configuration的过程添加Boot web starter来自动包含的。\n  这意味着Spring Boot将查看应用程序中存在的依赖项，属性和bean，并根据这些依赖项，对属性和bean进行配置。当然，如果我们想要添加自己的自定义配置，那么Spring Boot自动配置将会退回。\n配置模板引擎现在我们来看下如何在Spring和Spring Boot中配置Thymeleaf模板引擎。\n在Spring中，我们需要为视图解析器添加thymeleaf-spring5依赖项和一些配置：\n@Configuration@EnableWebMvcpublic class MvcWebConfig implements WebMvcConfigurer &#123;     @Autowired    private ApplicationContext applicationContext;     @Bean    public SpringResourceTemplateResolver templateResolver() &#123;        SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver();        templateResolver.setApplicationContext(applicationContext);        templateResolver.setPrefix(&quot;/WEB-INF/views/&quot;);        templateResolver.setSuffix(&quot;.html&quot;);        return templateResolver;    &#125;     @Bean    public SpringTemplateEngine templateEngine() &#123;        SpringTemplateEngine templateEngine = new SpringTemplateEngine();        templateEngine.setTemplateResolver(templateResolver());        templateEngine.setEnableSpringELCompiler(true);        return templateEngine;    &#125;     @Override    public void configureViewResolvers(ViewResolverRegistry registry) &#123;        ThymeleafViewResolver resolver = new ThymeleafViewResolver();        resolver.setTemplateEngine(templateEngine());        registry.viewResolver(resolver);    &#125;&#125;\n\n  SpringBoot1X只需要spring-boot-starter-thymeleaf的依赖项来启用Web应用程序中的Thymeleaf支持。  但是由于Thymeleaf3.0中的新功能，我们必须将thymeleaf-layout-dialect 添加为SpringBoot2XWeb应用程序中的依赖项。配置好依赖，我们就可以将模板添加到src/main/resources/templates文件夹中，SpringBoot将自动显示它们。\nSpring Security 配置  为简单起见，我们使用框架默认的HTTP Basic身份验证。让我们首先看一下使用Spring启用Security所需的依赖关系和配置。  Spring首先需要依赖  spring-security-web和spring-security-config  模块。接下来，  我们需要添加一个扩展WebSecurityConfigurerAdapter的类，并使用@EnableWebSecurity注解：\n@Configuration@EnableWebSecuritypublic class CustomWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter &#123;      @Autowired    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception &#123;        auth.inMemoryAuthentication()          .withUser(&quot;admin&quot;)            .password(passwordEncoder()            .encode(&quot;password&quot;))          .authorities(&quot;ROLE_ADMIN&quot;);    &#125;      @Override    protected void configure(HttpSecurity http) throws Exception &#123;        http.authorizeRequests()          .anyRequest().authenticated()          .and()          .httpBasic();    &#125;         @Bean    public PasswordEncoder passwordEncoder() &#123;        return new BCryptPasswordEncoder();    &#125;&#125;\n\n  这里我们使用inMemoryAuthentication来设置身份验证。同样，Spring Boot也需要这些依赖项才能使其工作。但是我们只需要定义spring-boot-starter-security的依赖关系，因为这会自动将所有相关的依赖项添加到类路径中。\nSpring Boot中的安全配置与上面的相同 。\n应用程序启动引导配置Spring和Spring Boot中应用程序引导的基本区别在于servlet。 Spring使用web.xml  或SpringServletContainerInitializer作为其引导入口点。 Spring Boot仅使用Servlet 3功能来引导应用程序，下面让我们详细来了解下\nSpring 引导配置Spring支持传统的web.xml引导方式以及最新的Servlet 3+方法。\n配置web.xml方法启动的步骤\n\nServlet容器（服务器）读取web.xml\nweb.xml中定义的DispatcherServlet由容器实例化\nDispatcherServlet通过读取WEB-INF / &#123;servletName&#125; -servlet.xml来创建WebApplicationContext。最后，DispatcherServlet注册在应用程序上下文中定义的bean\n\n使用Servlet 3+方法的Spring启动步骤\n容器搜索实现ServletContainerInitializer的类并执行SpringServletContainerInitializer找到实现所有类WebApplicationInitializer``WebApplicationInitializer创建具有XML或上下文@Configuration类WebApplicationInitializer创建DispatcherServlet与先前创建的上下文。\nSpringBoot 引导配置Spring Boot应用程序的入口点是使用@SpringBootApplication注释的类\n@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\n\n  默认情况下，Spring Boot使用嵌入式容器来运行应用程序。在这种情况下，Spring Boot使用public static void main入口点来启动嵌入式Web服务器。此外，它还负责将Servlet，Filter和ServletContextInitializer bean从应用程序上下文绑定到嵌入式servlet容器。 Spring Boot的另一个特性是它会自动扫描同一个包中的所有类或Main类的子包中的组件。\nSpring Boot提供了将其部署到外部容器的方式。我们只需要扩展SpringBootServletInitializer即可：\n/** * War部署 * * @author SanLi * Created by 2689170096@qq.com on 2018/4/15 */public class ServletInitializer extends SpringBootServletInitializer &#123;    @Override    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;        return application.sources(Application.class);    &#125;    @Override    public void onStartup(ServletContext servletContext) throws ServletException &#123;        super.onStartup(servletContext);        servletContext.addListener(new HttpSessionEventPublisher());    &#125;&#125;\n\n  这里外部servlet容器查找在war包下的META-INF文件夹下MANIFEST.MF文件中定义的Main-class，SpringBootServletInitializer将负责绑定Servlet，Filter和ServletContextInitializer。\n打包和部署  最后，让我们看看如何打包和部署应用程序。这两个框架都支持Maven和Gradle等通用包管理技术。但是在部署方面，这些框架差异很大。例如，Spring Boot Maven插件在Maven中提供Spring Boot支持。它还允许打包可执行jar或war包并就地运行应用程序。\n在部署环境中Spring Boot 对比Spring的一些优点包括：\n\n提供嵌入式容器支持\n使用命令java -jar独立运行jar\n在外部容器中部署时，可以选择排除依赖关系以避免潜在的jar冲突\n部署时灵活指定配置文件的选项\n用于集成测试的随机端口生成\n\n结论简而言之，我们可以说Spring Boot只是Spring本身的扩展，使开发，测试和部署更加方便。\n作者：乐傻驴链接：https://www.jianshu.com/p/ffe5ebe17c3a来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","categories":["学习","Java","疑惑"],"tags":["学习"]},{"title":"Java学习-疑惑之什么是对象","url":"/2021/04/05/Java%E5%AD%A6%E4%B9%A0-%E7%96%91%E6%83%91%E4%B9%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1/","content":"/**如何新建调用point数据类型*/package zuoye3;public class Wjl03 &#123; public static void main(String[]args) &#123;     point p1=new point(3,8);     point p2=new point(5,9);     System.out.println(p2.distance(p1,p2)); &#125;&#125;class point&#123;    int x=5,y=2;    point(int px,int py)&#123;        x=px;        y=py;    &#125;    point()&#123;             &#125;    double distance(point p1,point p2) &#123;        System.out.println(p1.x+&quot; &quot;+p2.x+&quot; &quot;+p1.y+&quot; &quot;+p2.y);        return Math.sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));    &#125;&#125;\n\n","categories":["学习","Java","疑惑"],"tags":["学习"]},{"title":"Nginx反向代理与正向代理","url":"/2022/11/11/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/","content":"Nginx\nNginx是一个轻量级的、高性能的Http和反向Web服务器，同时也提供IMAP&#x2F;POP3&#x2F;SMTP服务。\t–百度百科\n\n正向代理简述\n正向代理只是将代理服务器作为中转节点，所有的数据不管是对于起始客户端或最终服务端，两者都是相互透明的，也就是说两者相互知道对方的存在。\n例如国内用户通过代理访问一些404网站，实际上网站是知道用户的存在，用户也知道服务端的存在。\n反向代理简述\n反向代理是一种将客户端请求通过转发的方式，发送至服务器端，再将服务端的请求发送至客户端。客户端与服务端是相互不透明的，也就是说客户端即不知道服务端的存在，服务端也不知道客户端的存在。客户端认为自己在与代理服务器交互，而服务端也认为自己与代理服务器交互，而实际上是客户端与服务端在交互，代理服务器只负责数据的转发，并不对数据进行处理。\n但在实际应用中一般Nginx做服务器做负载均衡，会将客户端信息暴露给服务端，只有这样服务端才可根据真实的客户端信息进行业务处理。\n背景介绍存在此需求：客户端A将请求发送至服务器B，但不能向服务器B暴露自己的IP。根据以上，得出Nginx做反向代理服务器简直完美匹配。\n反向代理配置server&#123;\tlisten 58089;# server_name 当配置listen后不起作用\tserver_name localhost;\tlocation / &#123;\t\tproxy_pass http://xxx.xxx:8080;\t\t# 转发客户端Header\t\tproxy_set_header Host $http_host;\t# 转发Host 不设置时为proxy_pass地址\t\t# proxy_set_header X-Real_IP $remote_addr;\t# 转发Ip 不设置时服务端获取的为代理服务器地址\t\tproxy_set_header Referer &quot;&quot;;\t# 删除客户端请求Referer 不设置时默认为客户端请求地址\t&#125;&#125;\n\n通过以上配置即可实现需求，需要注意的是\n\n并非客户端未传入的参数，代理服务器就不转发，在数据传输中，可能有多余参数被添加并被转发。如Referer\n\n","categories":["Linux","Nginx","代理"],"tags":["技术"]},{"title":"Study Log","url":"/2022/12/07/Study%20Log/","content":"距离成为合格的搬砖工还有不少路要走，此文记录学习，激励自己\n更新时间：2022年12月8日00点07分\n\n目前基础部分比较薄弱，在逐步学习框架的同时应多加联系Java高级语法，同时学习数据结构与算法内容\n注意开发规范\n\n第一阶段⭐⭐Java基础⭐⭐⭐\n基础语法⭐⭐⭐⭐⭐\n数据类型\n流程控制\n\n\n数组⭐⭐⭐⭐⭐\n面向对象⭐⭐⭐⭐⭐\n方法\n重载\n封装\n继承\n多态\n\n\n抽象类⭐⭐⭐⭐⭐\n接口⭐⭐⭐⭐⭐\n枚举⭐⭐⭐⭐⭐\n常用类⭐⭐⭐\n集合类⭐⭐⭐⭐⭐\nString\n日期时间\n\n\n泛型⭐⭐⭐\n注解\n异常处理⭐⭐⭐\n运行异常⭐⭐⭐⭐⭐\n编译异常⭐⭐⭐⭐⭐\n自定异常⭐\n\n\n多线程\nIO流\n反射\n\nJava8⭐⭐\nStream API⭐⭐⭐\nLambda⭐⭐⭐\n新日期时间API\n接口默认方法\n\n第二阶段⭐⭐数据结构与算法计算机导论⭐⭐⭐⭐\n计算机发展历史\n计算机应用领域\n计算机发展方向\n计算机基本组成\n二进制\n编程语言发展\n\n操作系统⭐\n操作系统的组成⭐⭐⭐⭐⭐\n进程、线程⭐⭐⭐⭐\n进程 &#x2F; 线程间通讯方式\n进程调度算法\n进程 &#x2F; 线程同步方式\n进程 &#x2F; 线程状态\n死锁\n内存管理\n局部性原理\n\n计算机网络⭐⭐⭐⭐⭐\n网络分层模型\n网络传输过程\nIP、端口\nHTTP &#x2F; HTTPS 协议\nUDP &#x2F; TCP 协议\nARP 地址解析协议\n网络安全\nDNS 域名解析\n\n第三阶段Mysql数据库⭐⭐⭐\n基本概念⭐⭐⭐⭐⭐\nMySQL 搭建⭐⭐⭐⭐⭐\nSQL 语句编写⭐⭐⭐⭐⭐\n约束⭐⭐⭐⭐⭐\n索引⭐\n事务⭐⭐⭐⭐⭐\n锁机制\n设计数据库表⭐\n性能优化\n\n开发框架⭐JavaWeb⭐⭐Spring5⭐SpringMVC⭐MyBatis⭐MyBatis Plus⭐SpringBoot2⭐SpringSecurityMaven&#x2F;Gradle⭐开发规范⭐⭐\n代码规范\n代码风格\n命名\n其他规则\n\n\n代码校验（CheckStyle）\n提交规范\n\nGit⭐⭐\n工作区⭐\n分支⭐\n代码提交、推送、拉取、回退、重置⭐⭐⭐\n分支操作⭐⭐\n代码合并、解决冲突⭐⭐⭐\n标签\ncherry-pick\nGit Flow\n相关技术：SVN（比较老）⭐⭐⭐⭐⭐\n\nLinux⭐⭐\nLinux 系统安装⭐⭐⭐⭐⭐\n环境变量⭐⭐⭐⭐⭐\n文件管理⭐⭐⭐⭐⭐\n用户管理⭐⭐⭐⭐⭐\n内存管理\n磁盘管理\n进程管理⭐⭐\n网络管理⭐⭐⭐\n软件包管理⭐⭐\n服务管理⭐⭐⭐\n日志管理\nLinux 内核\n常用命令⭐⭐⭐⭐\n常用环境搭建⭐⭐⭐⭐\nShell 脚本编程⭐\nVIM 的使用⭐\n\n前端⭐⭐\nHTML⭐⭐⭐\nCSS⭐⭐⭐\nJavaScript⭐⭐⭐\nAjax\n\n\nVue\n\n第四阶段软件工程设计模式缓存消息队列Nginx微服务容器CI&#x2F;CD第五阶段项目实战第六阶段并发编程JVM架构设计第七阶段求职第八阶段持续学习","categories":["学习","Java"],"tags":["学习"]},{"title":"Ubuntu下切换默认Python版本","url":"/2021/05/09/Ubuntu%E4%B8%8B%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4Python%E7%89%88%E6%9C%AC/","content":"以 root 身份登录首先罗列出所有可用的python 替代版本信息\nupdate-alternatives --list python\n\n这一步可能会报错\nupdate-alternatives: error: no alternatives for python\n\n\n\n错误信息如果出现以上所示的错误信息，则表示 Python 的替代版本尚未被update-alternatives 命令识别。想解决这个问题，我们需要更新一下替代列表，将python2.7 和 python3.6 放入其中。\nupdate-alternatives --install /usr/bin/python python /usr/bin/python2.7 1  update-alternatives --install /usr/bin/python python /usr/bin/python3.6 2\n\n最后的1、2、3…代表序号，后面会有用\n再次列出可用的 Python 替代版本update-alternatives --list python\n\n\n\n切换版本我们就可以使用下方的命令随时在列出的 Python 替代版本中任意切换了\nupdate-alternatives --config python\n\n输入数字,选择版本\n查看变化在terminal中输入\npython\n\n","categories":["Linux","实用"],"tags":["Linux"]},{"title":"Ubuntu的防火墙","url":"/2021/04/14/Ubuntu%E7%9A%84%E9%98%B2%E7%81%AB%E5%A2%99/","content":"关闭ubuntu的防火墙ufw disable\n\n卸载了iptablesapt-get remove iptables\t#重启后即关闭所有防火墙\n\n开启防火墙ufw enable\n\n关闭ubuntu中的防火墙的其余命令iptables -P INPUT ACCEPT``iptables -P FORWARD ACCEPT``iptables -P OUTPUT ACCEPT``iptables -F\n\n","categories":["Linux","实用"],"tags":["Linux"]},{"title":"Windows将FRP设置为服务并开机自启","url":"/2021/03/10/Windows%E5%B0%86FRP%E8%AE%BE%E7%BD%AE%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%B9%B6%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF/","content":"配置文件下载WINSW，将WINSW解压至frp文件夹下，此一步非必须，只是为了有序。并重命名为winsw.exe。在目录下创建winsw.xml文件。编码必须为UTF-8？\n&lt;service&gt;    &lt;!-- 该服务的唯一标识 --&gt;    &lt;id&gt;frp&lt;/id&gt;    &lt;!-- 该服务的名称 --&gt;    &lt;name&gt;frp0.27.1-windows-amd64&lt;/name&gt;    &lt;!-- 该服务的描述 --&gt;    &lt;description&gt;frpc客户端 这个服务用 frpc 实现内网穿透&lt;/description&gt;    &lt;!-- 要运行的程序路径 --&gt;    &lt;executable&gt;D:\\Software\\frp\\frp_0.27.1_windows_amd64\\frpc.exe&lt;/executable&gt;    &lt;!-- 携带的参数 --&gt;    &lt;arguments&gt;-c frpc.ini&lt;/arguments&gt;    &lt;!-- 第一次启动失败 60秒重启 --&gt;    &lt;onfailure action=&quot;restart&quot; delay=&quot;60 sec&quot;/&gt;    &lt;!-- 第二次启动失败 120秒后重启 --&gt;    &lt;onfailure action=&quot;restart&quot; delay=&quot;120 sec&quot;/&gt;    &lt;!-- 日志模式 --&gt;    &lt;logmode&gt;append&lt;/logmode&gt;    &lt;!-- 指定日志文件目录(相对于executable配置的路径) --&gt;    &lt;logpath&gt;logs&lt;/logpath&gt;&lt;/service&gt;\n\n使用方法需管理员权限 \n//注册服务winsw.exe install//卸载服务winsw.exe uninstall//启动服务winsw.exe start//停止服务winsw.exe stop//重启服务winsw.exe restart//查看状态winsw.exe status\n\n","categories":["折腾","实用","内网穿透"]},{"title":"linux下开启SSH","url":"/2021/04/14/linux%E4%B8%8B%E5%BC%80%E5%90%AFSSH/","content":"#若无vim ，则安装。或安装宝塔自动安装sudo apt-get updatesudo apt-get install vim#查找并修改以下数据sudo vi /etc/ssh/sshd_config--&gt;PermitRootLogin yes #允许root登录PasswordAuthentication yes # 设置是否使用口令验证。#设置root密码sudo -ipasswd #输入密码无提示#修改后重启ssh服务service sshd restart # 或者/etc/initd .d /sshd restart\n\n","categories":["Linux","实用"],"tags":["Linux"]},{"title":"吃什么","url":"/2022/11/26/%E5%90%83%E4%BB%80%E4%B9%88/","content":"因工作原因，来到美丽的海南省。然而由于巨大的饮食习惯差异、消费水平差异，很难习惯这里的饮食。公司楼下竟有四家沙县小吃，快餐店荤菜从18软一下涨到26软…。所以决定自行解决吃饭问题，但随之而来的问题是，吃什么、怎么吃。\n幸运的是，开源社区Github有一个有趣的项目Anduin2017&#x2F;HowToCook，作者通过程序员思维来告诉你如何吃。\n但仍然存在的问题是，由于时间、厨艺、口味的问题，该项目并不完全适合我，于是摘选适合的部分。\n\n菜谱家常菜我的常做炒刀削系列辣椒炒肉炒刀削\n番茄炒蛋炒刀削\n…\n素菜\n拔丝土豆需油炸\n白灼菜心\n包菜炒鸡蛋粉丝\n菠菜炒鸡蛋\n炒滑蛋\n炒茄子\n炒青菜\n葱煎豆腐\n脆皮豆腐\n地三鲜\n干锅花菜\n蚝油三鲜菇\n蚝油生菜\n荷兰豆炒腊肠\n红烧冬瓜\n红烧茄子\n虎皮青椒\n话梅煮毛豆\n鸡蛋羹\n微波炉鸡蛋羹\n鸡蛋火腿炒黄瓜\n茄子炖土豆\n茭白炒肉\n椒盐玉米\n金针菇日本豆腐煲\n烤茄子\n榄菜肉末四季豆\n雷椒皮蛋\n凉拌黄瓜\n凉拌木耳\n凉拌莴笋\n凉拌油麦菜\n麻婆豆腐\n蒲烧茄子\n芹菜拌茶树菇\n陕北熬豆角\n上汤娃娃菜\n手撕包菜\n水油焖蔬菜\n素炒豆角\n酸辣土豆丝\n糖拌西红柿\n莴笋叶煎饼\n西红柿炒鸡蛋\n西红柿豆腐汤羹\n西葫芦炒鸡蛋\n洋葱炒鸡蛋\n\n荤菜\n白菜猪肉炖粉条配馒头\n冬瓜酿肉\n番茄红酱\n干煸仔鸡\n宫保鸡丁\n咕噜肉\n黑椒牛柳\n简易红烧肉\n南派红烧肉\n红烧猪蹄\n湖南家常红烧肉\n黄瓜炒肉\n黄焖鸡\n徽派红烧肉\n回锅肉\n尖椒炒牛肉\n姜炒鸡\n姜葱捞鸡\n酱牛肉\n酱排骨\n咖喱肥牛\n可乐鸡翅\n口水鸡\n辣椒炒肉\n老式锅包肉\n冷吃兔\n荔枝肉\n凉拌鸡丝\n萝卜炖羊排\n麻辣香锅\n麻婆豆腐\n梅菜扣肉\n啤酒鸭\n瘦肉土豆片\n水煮牛肉\n水煮肉片\n蒜苔炒肉末\n台式卤肉饭\n糖醋里脊\n糖醋排骨\n土豆炖排骨\n无骨鸡爪\n西红柿牛腩\n西红柿土豆炖牛肉\n乡村啤酒鸭\n香干芹菜炒肉\n香干肉丝\n香菇滑鸡\n香煎五花肉\n小炒黄牛肉\n小炒鸡肝\n小炒肉\n新疆大盘鸡\n血浆鸭\n羊排焖面\n洋葱炒猪肉\n鱼香茄子\n鱼香肉丝\n猪皮冻\n猪肉烩酸菜\n柱候牛腩\n孜然牛肉\n醉排骨\n\n水产\n白灼虾\n鳊鱼炖豆腐\n蛏抱蛋\n葱烧海参\n葱油桂鱼\n干煎阿根廷红虾\n红烧鲤鱼\n红烧鱼\n红烧鱼头\n黄油煎虾\n烤鱼\n咖喱炒蟹\n鲤鱼炖白菜\n清蒸鲈鱼\n清蒸生蚝\n水煮鱼\n蒜蓉虾\n糖醋鲤鱼\n微波葱姜黑鳕鱼\n香煎翘嘴鱼\n小龙虾\n油焖大虾\n\n早餐\n茶叶蛋\n桂圆红枣粥\n鸡蛋三明治\n煎饺\n金枪鱼酱三明治\n空气炸锅面包片\n美式炒蛋\n牛奶燕麦\n水煮玉米\n苏格兰蛋\n太阳蛋\n溏心蛋\n吐司果酱\n微波炉蛋糕\n燕麦鸡蛋饼\n蒸花卷\n蒸水蛋\n\n主食\n炒方便面约20分钟，热量高不推荐\n炒河粉约20分钟，热量高不推荐，不如炒方便面\n炒凉粉无凉粉\n炒馍馍太贵，2RMB&#x2F;个，热量高不推荐，不如炒方便面\n炒年糕不喜欢\n炒意大利面太贵，半成品50RMB&#x2F;500g\n蛋炒饭没饭\n豆角焖面\n韩式拌饭\n河南蒸面条\n基础牛奶面包\n茄子肉煎饼\n鲣鱼海苔玉米饭\n酱拌荞麦面\n空气炸锅照烧鸡饭\n醪糟小汤圆\n老干妈拌面\n老友猪肉粉\n烙饼\n凉粉\n麻辣减脂荞麦面\n麻油拌面\n电饭煲蒸米饭\n煮锅蒸米饭\n披萨饼皮\n热干面\n日式咖喱饭\n烧饼\n手工水饺\n酸辣蕨根粉\n汤面\n微波炉腊肠煲仔饭\n西红柿鸡蛋挂面\n扬州炒饭\n炸酱面\n蒸卤面\n中式馅饼\n煮泡面加蛋\n\n半成品加工\n半成品意面太贵，半成品50RMB&#x2F;500g\n空气炸锅鸡翅中无空气炸锅\n空气炸锅羊排无空气炸锅\n懒人蛋挞无烤箱\n凉皮配料过多\n牛油火锅底料有成品替代\n速冻馄饨约10分钟\n速冻水饺约10分钟\n速冻汤圆不喜欢\n炸薯条不喜欢\n\n汤与粥\n昂刺鱼豆腐汤鱼太贵，40RMB&#x2F;500g，约40分钟\n勾芡香菇汤不喜欢，约10分钟，需提前浸泡香菇15分钟\n金针菇汤不喜欢，约10分钟\n菌菇炖乳鸽无高压锅，约1.5小时\n罗宋汤不喜欢，约3小时\n米粥40分钟\n皮蛋瘦肉粥不喜欢，无电饭煲\n生汆丸子汤预计第一次制作耗时3小时\n西红柿鸡蛋汤不喜欢，约10分钟\n小米粥约30分钟\n银耳莲子粥不喜欢，约2小时，需提前浸泡银耳、莲子(2小时)\n紫菜蛋花汤约10分钟，需提前泡发紫菜(15分钟)\n\n饮料\n耙耙柑茶\n百香果橙子特调\n冰粉\n金菲士\n金汤力\n可乐桶\n奶茶\n奇异果菠菜特调\n酸梅汤\n酸梅汤（半成品加工）\n泰国手标红茶\n杨枝甘露\n长岛冰茶\nB52轰炸机\nMojito莫吉托\n\n酱料和其它材料\n草莓酱\n蒜香酱油\n糖醋汁\n糖色\n油泼辣子\n油酥\n炸串酱料\n蔗糖糖浆\n\n甜品\n不喜欢甜品\n奥利奥冰淇淋\n草莓冰淇淋\n反沙芋头\n烤蛋挞\n魔芋蛋糕\n戚风蛋糕\n提拉米苏\n雪花酥\n芋泥雪媚娘\n\n","categories":["日常"],"tags":["日常"]},{"title":"国外技巧","url":"/2021/09/16/%E5%9B%BD%E5%A4%96%E6%8A%80%E5%B7%A7/","content":"Telegram官方汉化https://t.me/setlanguage/zh-hans-beta\n","categories":["国外","技巧"],"tags":["技巧"]},{"title":"奇特简易出国--出国了但没完全出国","url":"/2021/11/18/%E5%A5%87%E7%89%B9%E7%AE%80%E6%98%93%E5%87%BA%E5%9B%BD-%E5%87%BA%E5%9B%BD%E4%BA%86%E4%BD%86%E6%B2%A1%E5%AE%8C%E5%85%A8%E5%87%BA%E5%9B%BD/","content":"404站项目地址Nginx Module for Google Mirror\n依赖库\npcre 正则\nngx_http_proxy_module 反向代理\nngx_http_substitutions_filter_module 多重替换\n\nInstallationDownload sources first## download the newest source# @see http://nginx.org/en/download.html#wget http://nginx.org/download/nginx-1.7.8.tar.gz## clone ngx_http_google_filter_module# @see https://github.com/cuber/ngx_http_google_filter_module#git clone https://github.com/cuber/ngx_http_google_filter_module## clone ngx_http_substitutions_filter_module# @see https://github.com/yaoweibin/ngx_http_substitutions_filter_module#git clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module\n\nBrand new installation## configure nginx customly# replace &lt;/path/to/&gt; with your real path#./configure \\  &lt;your configuration&gt; \\  --add-module=&lt;/path/to/&gt;ngx_http_google_filter_module \\  --add-module=&lt;/path/to/&gt;ngx_http_substitutions_filter_module\n\n宝塔安装\n创建模块文件夹\n\n下载库\ngit clone https://github.com/cuber/ngx_http_google_filter_module## clone ngx_http_substitutions_filter_module# @see https://github.com/yaoweibin/ngx_http_substitutions_filter_module#git clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module\n\n安装\n软件商店–Nginx–配置\n\n踩坑点，Nginx高版本应使用–add-dynamic-module引入第三方模块\n\n--add-dynamic-module=&lt;/path/to/&gt;ngx_http_google_filter_module \\--add-module=&lt;/path/to/&gt;ngx_http_substitutions_filter_module\n\n使用\n\n编辑Nginx配置文件，最上方加入\n踩坑点，Nginx高版本应手动引入第三方模块\n\n\n\nload_module modules/ngx_http_google_filter_module.so;\n\n\n\n编辑网站配置文件，加入\n\nresolver 8.8.8.8;location / &#123;  google on;&#125;\n\n注释，否则部分css,logo无法加载。原因：源站不存在静态资源，故关闭源站目录，全局反代。\n\nserver&#123;    # index index.php index.html index.htm default.php default.htm default.html;    # root domain;        #ERROR-PAGE-START  错误页配置，可以注释、删除或修改    #error_page 404 /404.html;    #error_page 502 /502.html;    #ERROR-PAGE-END        #PHP-INFO-START  PHP引用配置，可以注释或修改    # include enable-php-00.conf;    #PHP-INFO-END        #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效    # include /www/server/panel/vhost/rewrite/google.zyhwjl.cf.conf;    #REWRITE-END        # location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$    # &#123;    #     expires      30d;    #     error_log /dev/null;    #     access_log /dev/null;    # &#125;        # location ~ .*\\.(js|css)?$    # &#123;    #     expires      12h;    #     error_log /dev/null;    #     access_log /dev/null;     # &#125;\n\nGithub编辑网站配置文件\nlocation / &#123;proxy_set_header Accept-Encoding &quot;&quot;; #不使用压缩，如gzipproxy_set_header Connection &quot;&quot;;proxy_http_version 1.1; #使用http1.1长连接proxy_connect_timeout    10s; #设置连接超时proxy_read_timeout       10s; #设置读取超时proxy_set_header Host github.com;proxy_hide_header Strict-Transport-Security; #隐藏协议头，避免因为反向代理开启hstsproxy_pass https://github.com;&#125;\n\n注释内容参照404网站\n","categories":["折腾","实用","出国"],"tags":["出国技能"]},{"title":"数据结构与算法","url":"/2022/11/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95(%E4%B8%80)/","content":"稀疏数组适用范围适用于保存大量重复数据中夹杂不同数据\n需求保存五子棋盘\n一般方案将二维的棋盘已二维数组的方式保存\n数据量：6*7&#x3D;32个数据\n优化方案采用稀疏数组，仅保存不同的数据。\n第一行保存原始数据的行数、列数、不同数据的个数\n下方保存不同值的位置及值\n数据量：3*9&#x3D;27个数据\n\n","categories":["Java、数据结构与算法"],"tags":["编程、学习、数据结构与算法"]},{"title":"新的征程","url":"/2022/11/10/%E6%96%B0%E7%9A%84%E5%BE%81%E7%A8%8B/","content":"工作后很久没再更新博客，主要是工作的无意义加班占用了大量个人时间\n另外HEXO的更新也实在繁琐，但根据大佬教程，已可实现自动部署，所以可能会经常更新了\n","categories":["日常"],"tags":["日常"]},{"title":"机器人说明书","url":"/2022/11/30/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%AF%B4%E6%98%8E%E4%B9%A6/","content":"你可能用到的工具Alook浏览器官网 - 8倍速，极简且强大的移动手机浏览器，Alook唯一官方网站 (alookweb.com)\nJD命令：登录&#x2F;登陆&#x2F;上车&#x2F;查询\n用法：跟随提示操作\n用途 ：挂豆\n收益：看脸，目前低得离谱\nELM命令\n\n饿了记录&#x2F;饿了么记录&#x2F;饿了么登录&#x2F;饿了么登陆&#x2F;记录饿了\n饿了查询&#x2F;饿了么查询&#x2F;查询饿了\n\n用法：Alook浏览器登录抓CK，发送记录饿了，发送CK，等一天，发查询饿了\n用途 ：挂ELM豆，脚本较慢限制100个账号\n收益：100-200豆(1-2元)\n优惠券&#x2F;比价命令： 无\n用法：发送商品链接&#x2F;口令，获取历史价格，优惠价格\n用途 ：购物优惠（淘B、天M、拼DD）\n收益：商品低价\n一手线报命令： 无\n用法：群内分享优惠商品、常有Bug价、个人自用线报资源转发\n用途 ：活动、捡漏\n收益：拼运气、手速\n","categories":["羊毛"],"tags":["羊毛"]},{"title":"某面板插件解锁","url":"/2021/12/16/%E6%9F%90%E9%9D%A2%E6%9D%BF%E6%8F%92%E4%BB%B6%E8%A7%A3%E9%94%81/","content":"面板仅7.7.0下支持解锁\n更新时间：2022年11月11日10点20分\n\n下载\n两种方法\n貌似不可解锁三方\n推荐安装插件：\n\nNginx防火墙\n网站监控报表\n\n\n经测试# 无此文件用下方解决方法# 打开目录/www/server/panel/class找到并编辑panelplugin.py文件,使用Ctrl+F搜索并找到softList[&#x27;list&#x27;] = tmpList# 这段代码，在其下方添加如下代码：# 专业版破解softList[&#x27;pro&#x27;] = 1for soft in softList[&#x27;list&#x27;]:soft[&#x27;endtime&#x27;] = 0# 二选一！！！# 企业版破解softList[&#x27;ltd&#x27;] = 99999999999for soft in softList[&#x27;list&#x27;]:soft[&#x27;endtime&#x27;] = 0\n\n示例：\n\n未测试# 找到www/server/panel/data/plugin.json# 打开文件# 点击搜索，查找/替换&quot;endtime&quot;: -1# 全部替换为&quot;endtime&quot;: 999999999999# 保存# 重启面板\n\n其他命令去除宝塔面板强制登陆#删除登录文件命令mv /www/server/panel/data/bind.pl ./或#重命名此文件为bind.pl.bakmv /www/server/panel/data/bind.pl /www/server/panel/data/bind.pl.bak\n","categories":["折腾","实用","服务器"],"tags":["折腾"]},{"title":"欢迎来到ZYHWJLのBLOG","url":"/2020/09/08/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0ZYHWJL%E3%81%AEBLOG/","content":"本博客仅限个人测试使用\n\n不含任何商业性质\n\n严格遵守中华人民共和国各项法律法规\n","tags":["首页"]},{"title":"热量控制","url":"/2022/11/28/%E7%83%AD%E9%87%8F%E6%8E%A7%E5%88%B6/","content":"\n换算公式：1千卡&#x3D;1大卡&#x3D;1000卡&#x3D;1000卡路里 &#x3D;4186焦耳&#x3D;4.186千焦。\n\n根据体重年龄计算每日所需热量基础代谢计算方法是什么_39健康网_减肥\nBMR &#x3D; 66+(13.7× 体重(kg))+(5×身高(cm)) – (6.8×年龄(岁))\n1808 Kcal\n减脂应在此基础减200-300 即1508-1608\n早餐固定：\n\n奶266KJ/100ml*200ml+面包1642KJ/100g*1000g/24个+肉松1737KJ/100g*500g/18个\n532KJ+684KJ+482KJ=1698KJ=406 Kcal\n剩余1508-406&#x3D;1102\n\n午餐：\n\n(鸡胸肉125g+青椒200g)*87Kcal/100g=283Kcal+水煮面100g*325Kcal/100g=325Kcal+生菜200g*15Kcal/100g=30Kcal&#x3D;638Kcal\n剩余1102-638&#x3D;470\n\n晚餐：\n\n(鸡胸肉125g+青椒200g)*87Kcal/100g=283Kcal+水煮蛋50g*143Kcal/100g=71Kcal&#x3D;354Kcal\n剩余470-354&#x3D;116\n\n注意\n日常摄入一般不可低于此值，减脂非一朝一夕之功，切不可盲目节食。\n如有高强度运动应适量增加饮食\n","categories":["日常"],"tags":["日常"]},{"title":"网易云音乐-解锁灰色","url":"/2020/09/24/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90-%E8%A7%A3%E9%94%81%E7%81%B0%E8%89%B2/","content":"项目地址\n\n网易云音乐是我个人较为常用的音乐播放器，然而很多音乐网易都没有版权，例如周董。偶然发现这个项目，以此记录我的折腾记录。本人设备和精力有限，只总结出windows客户端、macOS客户端、Android客户端的使用方法。\n\n\nAndroid客户端\n安卓客户端的使用方法较为简单，稳定。\n\n运行环境：\nxposed\nMagisk–&gt;Edxposed\n太极阳\n\n插件\nUnblockMusic Pro 2.8.2\n\n获取方式\n酷安\n个人网盘备份\n\n客户端版本\n魅族专版最新版\n 截止7.3.10.237476可用，不清楚是否可运行于非魅族手机，不清楚以后是否可用\n 获取方式：魅族应用商城、个人网盘备份\n\n非魅族\n 官方原版7.0.0\n\n\n补充\n可同时安装网易云音乐插件以优化使用体验。\n\n\nWindows客户端\nWindows客户端的使用方法最为简单。\n\n运行环境：\n服务器端Unblockneteasemusic\n\n获取方式\ndock版nondance-unblockneteasemusic  仅本人目前使用方式，并非仅此一种方式。\n\n客户端版本\n官方最新版客户端，非uwp版。\n\n使用方式设置-代理-地址、端口\n\nMacOS客户端\n因Apple限制等原因，苹果系最为繁琐，本人仅探索出macOS使用方法。\n\n运行环境​\t本地nodejs服务\n使用方法\n本地安装nodejs、git\ngit clone https://github.com/nondanee/UnblockNeteaseMusic.gitcd UnblockNeteaseMusic\n\n修改hosts   1. 获取su权限sudo su       2. 执行 vim /etc/hosts       3. 最下方添加                             127.0.0.1       music.163.com                             127.0.0.1       interface.music.163.com\n\n运行服务node UnblockNeteaseMusic/app.js -p 80:443 -f 59.111.181.38其中59.111.181.38为本地ping music.163.com获取到的IP\n\n\nApple其他设备信任证书挂载代理即可，使用openwrt或老毛子可实现透明代理\n另推荐使用咪咕音乐，乐库全、界面\n\n  至此教程结束 ","categories":["折腾","实用"],"tags":["实用"]},{"title":"腾讯云Cloudbase学习记录","url":"/2021/03/28/%E8%85%BE%E8%AE%AF%E4%BA%91Cloudbase%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"安装Node.js安装Node.js，推荐LTS版本。\n安装Cloudbasenpm install -g @cloudbase/cli\n\n国内由于你懂的原因速度较慢，推荐换源后安装。\nnpm config set registry https://r.cnpmjs.org/\n\n安装结束后以cloudbase --version–tcb --version查看是否成功。\n常用命令tcb login                                 #登录\ntcb logout                                #登出\ntcb hosting detail                        #静态网站托管状态\ntcb hosting deploy localpath cloudpath    #静态网站托管部署\ntcb hosting delete cloudpath              #静态网站托管删除\n-e                                        #指定环境id\n\n特别的cloudbaserc.json所在目录下无需-e命令，\n\n未识别到有效的环境 Id，请使用 cloudbaserc 配置文件进行操作或通过 -e 参数指定环境 Id\n\n该错误可由此解决。\n\n引用CloudBase CLI\n","categories":["折腾","云开发","腾讯云"],"tags":["云开发"]},{"title":"踩坑腾讯云函数(SCF)","url":"/2021/11/30/%E8%B8%A9%E5%9D%91%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0(SCF)/","content":"\n云函数\n\n时区问题时区默认为UTC+0，如需使用北京时间，须设置环境变量TZ=Asia/Shanghai\n云函数安装依赖pip install numpy -t .//numpy替换为包名，不能省略&quot;.&quot;","categories":["踩坑","腾讯云","云函数"],"tags":["踩坑"]},{"title":"远程桌面添加SSL","url":"/2020/12/18/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%B7%BB%E5%8A%A0ssl-windows-win10-RDS-%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2-SSL/","content":"ssl是数字证书的一种，简而言之是为了验证客户端与服务器的连接是否安全。启用ssl后，所有数据将通过加密协议传输，避免明文传输密码而带来的风险。\n申请ssl证书本部分不多赘述，网上有大量教程。不过值得一提的是，不同的客户端对不同的颁发机构信任不一。另外如果需要泛域名证书一般需要进行企业认证、付费等，或通过Let’s Encrypt免费申请，但由于相关原因部分客户端不信任该颁发机构，请自行斟酌。\n添加ssl证书本教程理论适用于windows所有操作系统，本人使用win10 20H2测试可用。–2020.12.18使用mmc（命令行运行）,然后文件-&gt;添加&#x2F;删除管理单元-&gt;证书-&gt;计算机账户-&gt;本地计算机(运行此XXXXX)，然后在左侧控制台节点的证书-&gt;个人下，右键单击右侧空白-&gt;所有任务-&gt;导入，然后按提示选择刚才的.p12另见补充说明文件，并输入正确的密码。\n为RDS指定证书注册表regedit(CMD)路径为 计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp加入如下项Value name: SSLCertificateSHA1HashValue type: REG_BINARY（二进制值）Value data:&lt;certificate thumbprint&gt;（证书指纹）其中Value data为可以在刚才加入的证书窗口查到的颁发下来的SSL证书的sha1指纹（20个16进制数），这里貌似不能直接复制粘贴，手动敲一遍也还好，反正不多，注意别抄错就好。\n为证书配置权限在刚才的mmc控制台，选中你的证书右键-&gt;所有任务-&gt;管理私钥，弹出的窗口和NTFS的权限管理窗口类似，在权限对话框中选添加，用户名直接输入 NETWORK SERVICE 并检查，通过后确定添加，然后保证权限中的读取为挑勾选中状态即可。\n结语如果证书过期或其它原因导致需要替换新的证书时，需要在重新导入证书，设置私钥访问权限设置新的fingerprint后，重启系统才能生效。\n\n参考文章使用StartSSL(Let’s Encrypt)的免费SSL证书为Windows远程桌面RDS服务指定受信任的证书SSL certificates with StartSSL, Microsoft IIS, Microsoft RDP and OpenSSL How to Force Remote Desktop Services on Windows 7 to Use a Custom Server Authentication Certificate for TLS\n补充某些证书颁发者未使用默认的.p12文件，但一般会颁发证书加私钥的形式，若没有私钥，如crt格式，则无法配置权限。如某讯云格式则需导入pfx后输入txt中的私钥。\n另外，经此方法配置加密传输后，在较低版本的RD客户端不信任远程电脑。实测Window 7及以上无此问题。\n","categories":["折腾","实用"]},{"title":"随身Wifi","url":"/2022/11/11/%E9%9A%8F%E8%BA%ABWifi/","content":"随身Wifi是一个装载安卓系统的随身的Wifi发射装置，一般可通过商家内置的eSim进行上网，流量价格一般远低于三大运营商。但商家可通过后台任意设置限速、虚标流量、甚至跑路，所以使用商家的eSim上网并非此装置存在的意义。\n而由于商家在此设备后期的流量费用可获得巨大利益，大部分商家将此设备低价甚至亏本销售，以降低用户的试错成本，最终掉入商家的陷阱。\n正因此，折腾此设备才有意义。优势：便宜，性能不算太差。\n分类主要是根据处理器的不同，主要分为高通410与中兴微两大阵营。两者各有优势，也各有劣势，当然了这里讨论的是未物理升级、加工的设备。\n410的优势主要在于有9008，不怕折腾，遇事不决9008，劣势则是信号相对中星微没那么好。发热。\n中兴微的优势则在于信号好，不发热，劣势自然就是不能折腾。\n系统刷机的话只推荐原版修复或Debian，也就是说不推荐OpenWrt\nOpenWrt非常强，对于软路由或者矿渣硬路由来说都是相当不错的选择，然而随身Wifi性能拉跨，加解密能力几乎没有，再加上OpenWrt对信号的影响(限速1Mbps，可能已有解决方案，未深入研究)，且反人类的对时方式 date -u -s &quot;$(curl 某网址 -kIs | grep Date | awk &#39;&#123;sub(/Jan/,&quot;1&quot;); sub(/Feb/,&quot;2&quot;); sub(/Mar/,&quot;3&quot;); sub(/Apr/,&quot;4&quot;); sub(/May/,&quot;5&quot;); sub(/Jun/,&quot;6&quot;); sub(/Jul/,&quot;7&quot;); sub(/Aug/,&quot;8&quot;); sub(/Sep/,&quot;9&quot;); sub(/Oct/,&quot;10&quot;); sub(/Nov/,&quot;11&quot;); sub(/Dec/,&quot;12&quot;); print $5&quot;-&quot;$4&quot;-&quot;$3,$6;&#125;&#39;)&quot;某些特殊情况仅可此方式对时(来自酷安)，实在不推荐。\n目前不清楚OpenWrt的V2在这种特殊情况是否支持域名解析，及USB共享网络是否限速。未验证\nDebian刷Debian主要是作为服务器使用，如若是特殊情况使用，原版系统就足够，且表现也比Debian好不少\n在我使用中将Debian作为Nginx反向代理服务器并将其内网穿透使用，隐藏一些请求的真实IP，还有酷安苏苏小亮亮大佬的物联网小车项目其他应用也确实想不到了\n原版系统原版系统则可通过酷安水遍大佬的刷机工具折腾，一切都不在话下\n刷机一般过程备份\n使用水遍大佬提供的miko工具进行救砖包备份\n使用高通9008工具对系统各个分区备份\n使用星海SVIP对基带备份\n\n刷机原版系统修改\n使用水遍大佬工具修改system分区，主要是开ADB，看切卡密码\n刷入修改后的system分区\n装面具、Es、6k桌面\n修补boot分区\n刷入修补的boot分区\n刷入插件\n折腾-&gt;放弃-&gt;9008刷救砖包\n\nDebian&#x2F;OpenWrt\n重复1、2\n执行刷机包的flash.bat(Windows)\n重复7\n\nDebian相关命令开机关灯开usb共享网络#创建或修改/etc/rc.local并赋予可执行权限#启动服务systemctl start rc.local#!/bin/bashsudo echo none&gt; /sys/class/leds/blue\\:wifi_tx/triggersudo echo none &gt; /sys/class/leds/green\\:wifi_rx/triggersudo nmcli c up usb\t#usb为名称\n\n定时任务#修改/etc/crontab文件1 5 * * * root curl http://192.168.1.1/boaform/admin/formReboot &gt;&gt; /dev/null 2&gt;&amp;10 5 * * * root curl &quot;http://192.168.1.1/boaform/admin/formLogin&quot; --data-raw &quot;xxx&quot; &gt;&gt; /dev/null 2&gt;&amp;110 8,20 * * * root python3 /root/xx.py &gt;&gt; /root/amar/logTest.txt 2&gt;&amp;1#重启服务systemctl restart cron\n\n安装python-pip\napt-get install python-pip -y\n\n","categories":["Linux"],"tags":["折腾"]},{"title":"黑群晖Active Backup","url":"/2022/11/12/%E9%BB%91%E7%BE%A4%E6%99%96Active%20Backup/","content":"Active Backup是一款群晖官方套件，主要用于备份实体机、虚拟机等，支持全量、增量备份\n黑群晖使用此套件需要激活，白群晖直接登录即可使用\n环境群晖6.2.3 型号 918+\n激活https://地址:端口/webapi/auth.cgi?api=SYNO.API.Auth&amp;method=Login&amp;version=1&amp;account=管理员账户&amp;passwd=管理员密码https://地址:端口/webapi/entry.cgi?api=SYNO.ActiveBackup.Activation&amp;method=set&amp;version=1&amp;activated=true&amp;serial_number=%22你的序列号%22\n\n使用","categories":["黑群晖"],"tags":["黑群晖"]},{"title":"黑群晖Moments无法显示缩略图，无法转换视频、Video解决","url":"/2022/11/10/%E9%BB%91%E7%BE%A4%E6%99%96Moments%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%BC%A9%E7%95%A5%E5%9B%BE%EF%BC%8C%E6%97%A0%E6%B3%95%E8%BD%AC%E6%8D%A2%E8%A7%86%E9%A2%91%E3%80%81Video%E8%A7%A3%E5%86%B3/","content":"黑群晖Moments无法显示缩略图，无法转换视频、Video解决问题原因\n未洗半白&#x2F;全白\n未替换补丁&#x2F;未替换ffmpeg\n\n对于第一种情况，根据需要进行洗白，洗白教程看最下方\n对于第二种情况，查看ffmpeg替换及Moments补丁替换\nffmpeg替换套件源添加 https://packages.synocommunity.com/ 并下载ffmpeg\n登录root用户，自行搜索 群晖root权限获取\n# 备份原始mmfpegmv /usr/bin/ffmpeg /usr/bin/ffmpeg_BAK# 创建第三方ffmpeg软连接ln -s /volume1/@appstore/ffmpeg/bin/ffmpeg /usr/bin/ffmpeg\n\n进入Moments重建索引即可Moments补丁替换教程\n由于黑群晖装载大多为6.2.X系统，此系统对转码进行限制，且ffmpeg自带为旧版本，不支持视频等转码\nMoments补丁替换补丁下载\n\n停用Moments\n使用WinScp通过root用户登录\n进入目录 /var/packages/SynologyMoments/target/usr/lib/\n然后将 libsynophoto-plugin-detection.so 这个文件，给重命名，备份一下，比如在结尾加上 .bak，进行备份\n然后将我们下载的这个补丁，拖入进去\n拖入补丁后，我们右键这个补丁，点击属性\n设置一下权限，将组和拥有者改成 SynologyMoments，并且将下面权限改成 0755\n启用Moments并重建缓存\n\n洗白教程区别：半白无QuickConnect，除此外与全白无任何区别\n半白通过Viutul Machine创建虚拟群晖系统获取正版序列号，替换启动盘序列号进行洗白\n全白某鱼、某宝购买正版序列号+Mac码并替换启动盘\n","categories":["黑群晖"],"tags":["折腾"]}]